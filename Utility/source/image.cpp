//
// Created by Maria Carmen D'urbano on 27/08/25.
//

#include "image.h"

#include <algorithm>
#include <fstream>
#include <map>
#include <iostream>
#include <cstdlib>
#include <filesystem>
#include <unordered_map>

std::string buildClockExpression( const std::map<std::string,int>& floorValues,
                                    const std::set<std::string>& zeroFraction,
                                    const std::vector<std::vector<std::string>>& fractionalOrder) {
    std::stringstream ss;
    std::map<int, std::vector<std::string>> byFloor;
    for (const auto& [clk, fl] : floorValues) {
        byFloor[fl].push_back(clk);
    }
    auto max = std::max_element(
                   floorValues.begin(), floorValues.end(),
                   [](const auto& a, const auto& b) {
                       return a.second < b.second;
                   })->second;

    std::map<std::string, std::pair<int,int>> fracPos;
    for (auto it = byFloor.begin(); it != byFloor.end(); ++it) {
        const auto& numb = *it;
        bool found = false;
        for (const auto clk : numb.second) {
            if(zeroFraction.find(clk) != zeroFraction.end()) {
                ss << clk << "=";
                found = true;
            }
        }
        if(found) {
            ss << std::to_string(numb.first);
        }
        found = false;
        for (const auto group : fractionalOrder) {
            std::vector<std::string> frac;
            for (const auto clk : numb.second) {
                if(std::find(group.begin(), group.end(), clk) != group.end()) {
                    frac.push_back(clk);
                }
            }
            if(!frac.empty() && ss.str().empty()) {
                ss << std::to_string(numb.first) << "<";
            }
            if(frac.size()>1) {
                for(auto c = frac.begin(); c != frac.end(); ++c) {
                    if (std::next(c) == frac.end()) {
                        ss << *c;
                    }
                    else ss << *c << "~";
                }
            }
            else if (frac.size() == 1) {
                if(ss.str().back() != '<')
                    ss << "<" << frac[0];
                else  ss << frac[0];
            }

        }
        int lastFloor = byFloor.rbegin()->first;  // il valore massimo dei floor
        for (const auto& clk : byFloor.rbegin()->second) {
            if (lastFloor == max && zeroFraction.find(clk) == zeroFraction.end()) {
                // Caso speciale: clock al massimo, non in zeroFraction
                return clk + ">" + std::to_string(max);
            }
        }


        auto succ = std::next(it);
        if (succ != byFloor.end()) {
            ss << "<";
        }
        if (succ->first-numb.first > 1 && (zeroFraction.empty() || zeroFraction.find(std::next(it)->second.front()) == zeroFraction.end())) {
            ss << std::to_string(numb.first+1) << "<" << std::to_string(succ->first) << "<";
        }

    }
    if (!ss.str().empty() && !std::isdigit(ss.str().back())) {
        std::string last = std::to_string(byFloor.rbegin()->first+1);
        ss << "<" << last;
    }
    std::string result = ss.str();
    return result;
}

void exportRTSGraphSmart(
    const RTS& rts,
    const TAr arena,
    const std::string& dotFile,
    const std::string& logic)
{
    std::ofstream file(dotFile);
    if (!file) {
        std::cerr << "Error: unable to open " << dotFile << " for writing.\n";
        return;
    }

    Region initialRegion = arena.R;

    file << "digraph RTS {\n";
    file << "  rankdir=TB;\n";
    file << "  splines=true;\n";
    file << "  label=\"RTS generated by BFS function starting from the green region\\n"
         << "going " << logic << "\n\n\";\n";
    file << "  labelloc=t;\n";                       // t = top
    file << "  fontsize=16;\n";                      // dimension of the title
    std::stringstream ssNote;
    ssNote << "Initial region: " << initialRegion.location << "\\nFloorValues: ";
    for (const auto& [clk, val] : initialRegion.floorValues) {
        ssNote << clk << "=" << val << " ";
    }

    ssNote << "\\nZero fraction clocks: ";
    for (const auto& clk : initialRegion.zeroFraction) {
        ssNote << clk << " ";
    }

    ssNote << "\\nFractional order:\\n";
    for (const auto& group : initialRegion.fractionalOrder) {
        ssNote << "  [";
        for (size_t i = 0; i < group.size(); ++i) {
            ssNote << group[i];
            if (i != group.size() - 1) ssNote << ", ";
        }
        ssNote << "]\\n";
    }

    ssNote << "\\nTransitions:\\n";
    for (const auto& t : arena.transitions) {
        ssNote << t.sourceLocation << " --[" << t.action.action;
        if (!t.resetClocks.empty()) {
            ssNote << ", reset {";
            for (auto it = t.resetClocks.begin(); it != t.resetClocks.end(); ++it) {
                if (it != t.resetClocks.begin()) ssNote << ", ";
                ssNote << *it;
            }
            ssNote << "}";
        }
        ssNote << "]--> " << t.targetLocation << "\\n";
    }

    file << "  Info [shape=plaintext, label=\"" << ssNote.str() << "\"];\n";
    file << "  node [shape=box, style=filled, fillcolor=white, fontname=Helvetica, fontsize=12];\n";
    file << "  edge [fontsize=10, color=black, arrowsize=0.8];\n";


    std::map<std::string,int> regionIndex;
    for (int i = 0; i < rts.regions.size(); ++i)
        regionIndex[rts.regions[i].ID()] = i;

    // nodes = region
    for (int i = 0; i < rts.regions.size(); ++i) {
        auto& r = rts.regions[i];
        std::string clock = buildClockExpression(r.floorValues, r.zeroFraction, r.fractionalOrder);
        std::string color = r.ID()==initialRegion.ID() ? "lightgreen" : "lightblue";
        file << "  R" << i << " [label=\"" << "R" << i
             << "\\n" << r.location << "\n" << clock << "\", fillcolor=" << color << "];\n";
    }

    // same location on the same row
    std::map<std::string, std::vector<int>> locationGroups;
    for (int i = 0; i < rts.regions.size(); ++i) {
        locationGroups[rts.regions[i].location].push_back(i);
    }

    for (auto& [loc, indices] : locationGroups) {
        // ascent order
        std::sort(indices.begin(), indices.end(), [&](int a, int b) {
            std::string ca = buildClockExpression(rts.regions[a].floorValues, rts.regions[a].zeroFraction, rts.regions[a].fractionalOrder);
            std::string cb = buildClockExpression(rts.regions[b].floorValues, rts.regions[b].zeroFraction, rts.regions[b].fractionalOrder);
            return ca < cb;
        });

        file << "  { rank=same; ";
        for (int idx : indices)
            file << "R" << idx << "; ";
        file << "}\n";
    }

    // arches
    for (const auto& t : rts.arches) {
        int idxSource = regionIndex[t.source.ID()];
        int idxTarget = regionIndex[t.target.ID()];
        std::string label = (t.transition == "tau") ? "Ï„" : t.transition;
        file << "  R" << idxSource << " -> R" << idxTarget << " [label=\"" << label << "\"];\n";
    }

    file << "}\n";
    file.close();
}

void openRTSGraphSVG(const std::string& dotFile, const std::string& svgFile) {
    std::string command = "dot -Tsvg " + dotFile + " -o " + svgFile;
    int ret = std::system(command.c_str());
    if (ret != 0) {
        std::cerr << "Error generating SVG: command failed\n";
        return;
    }

    std::string openCommand = "open " + svgFile;
    std::system(openCommand.c_str());
}